// Read the following article for more information about generics:
// https://docs.oracle.com/javase/tutorial/java/generics/types.html

public class Generics {
	public static void main(String[] args) {
		Dog dog = new Dog("Koro", 3, "White");
		Cat cat = new Cat("Mona", 5, "Black");
		Bird bird = new Bird("Sunny", 1);
		Platypus platypus = new Platypus("Bill", 4);
		int[] a1 = { 1, 2, 3, 4, 5 };
		double[] a2 = { 1.1, 2.2, 3.3, 4.4, 5.5 };
		String[] a3 = { "one", "two", "three", "four", "five" };
		Animal[] a4 = { dog, cat, bird, platypus };

		print(a1);
		print(a2);
		print(a3);
		print(a4);

		Container<Integer> c1 = new Container<Integer>(1);
		System.out.println(c1.getValue());
		c1.setValue(2);
		System.out.println(c1.getValue());

		Container<Double> c2 = new Container<Double>(1.1);
		System.out.println(c2.getValue());
		c2.setValue(2.2);
		System.out.println(c2.getValue());

		Container<String> c3 = new Container<String>("hello");
		System.out.println(c3.getValue());
		c3.setValue("world");
		System.out.println(c3.getValue());

		Barn<Animal> barnForAnyone = new Barn<Animal>();
		barnForAnyone.setValue(dog);
		barnForAnyone.visit();
		barnForAnyone.setValue(cat);
		barnForAnyone.visit();
		barnForAnyone.setValue(bird);
		barnForAnyone.visit();
		barnForAnyone.setValue(platypus);
		barnForAnyone.visit();

		Barn<Mammal> barnForMammals = new Barn<Mammal>();
		barnForMammals.setValue(dog);
		barnForMammals.visit();
		barnForMammals.setValue(cat);
		barnForMammals.visit();
		barnForMammals.setValue(platypus);
		barnForMammals.visit();
	}

	// Generics allow you to define classes, interfaces, and methods that have placeholders for the data type.
	// You can think of a generic type as a 'type to be specified later'.
	// This allows us to design classes and methods that defer the specification of one or more types until the class or method is declared and instantiated by client code.
	// For example, let's say we wanted to create a method which prints an array...

	// We could write individual methods to print an array of integers, doubles, and strings...
	// But this wouldn't scale well if we wanted to print an array of a different type.
	// Instead, we can use generics to create a single method that can print an array of any type.
	// To create a generic method, we define a type parameter by placing it in angle brackets before the return type.
	// It's common to use the letter 'T' as the type parameter, but you can use any valid Java identifier.
	// The type parameter will be used as a placeholder for the actual type that will be specified when the method is called.
	//
	// You might be thinking- why not just use Object instead of generics?
	// The main advantage of generics over using Object is that generics provide compile-time type safety.
	// Let's say we created a print(Object arr) method and passed an array of integers.
	// This would be allowed, but we'd have to cast 'arr' into an int[] before we could access its elements.
	// If we passed an array of strings, we'd have to cast 'arr' into a String[].
	// This would be cumbersome and error-prone.
	// With generics, the compiler can enforce type safety and catch type mismatches at compile time.
	// This makes generics more flexible and safer than using Object.
	//
	// Under the hood, the compiler generates a separate type or method for each type argument.
	// For example, this file invokes print<Integer>, print<Double>, print<String>, and print<Animal>.
	// These are distinct methods that are generated by the compiler as overloads of the generic print method.
	//
	// Note that Java uses type erasure to implement generics.
	// This means that the generic type information is not available at runtime.
	// In practice, this means that you cannot use instanceof to check for a generic type.
	// For example, the following code would not compile:
	// if (array instanceof T[]) { ... }
	// This is because the type parameter T is not available at runtime.
	// Also note that Java does not allow the creation of generic arrays.
	// For example, the following code would not compile:
	// T[] array = new T[10];
	// This is because the type parameter T is not available at runtime.
	private static <T> void print(T[] array) {
		System.out.print("[ ");
		for (int i = 0; i < array.length; i++) {
			System.out.print(array[i] + " ");
		}
		System.out.println("]");
	}
}

// We can also create generic classes, which are classes that can operate on a type specified by the client.
// For example, we could create a Container<T> class that holds a single value of type T.
// This isn't a very useful class, but it demonstrates the concept of a generic class.
// The type parameter T is specified in angle brackets after the class name.
// When we create an instance of Container, we specify the type argument in angle brackets.
// For example, Container<Integer> c1 = new Container<Integer>(5); creates a Container that holds an integer.
// We can then set the Value property to an integer, and the compiler enforces type safety.
// This is powerful because it would allow us to treat the value as an integer without casting.
// We could also create a Container<Double> or Container<String> to hold values of those types.
// The type parameter T can be used in fields, properties, methods, and parameters of the class.
// This allows us to create classes that are flexible and reusable across different types.
//
// Note that Java does not allow primitive types as type arguments.
// For example, the following code would not compile:
// Container<int> c = new Container<int>(5);
// This is because generics require reference types.
// Thankfully, all eight primitive types have corresponding wrapper classes in the java.lang package:
// int -> Integer
// double -> Double
// boolean -> Boolean
// char -> Character
// byte -> Byte
// short -> Short
// long -> Long
// float -> Float
// You can use these wrapper classes as type arguments for generics.
// This is known as autoboxing and unboxing, and it allows you to use primitive types with generics seamlessly.
// Autoboxing: The boxed form was expected but a primitive was provided, so the compiler automatically converts the primitive to its corresponding wrapper class.
// Unboxing: The primitive form was expected but a boxed type was provided, so the compiler automatically converts the wrapper class to its corresponding primitive type.
class Container<T> {
	protected T value;

	public Container(T value) {
		this.value = value;
	}

	public T getValue() {
		return value;
	}

	public void setValue(T value) {
		this.value = value;
	}
}

// We can also place restrictions on the type parameter using constraints.
// For example, we could create a Barn<TAnimal> class that can only hold types that derive from Animal.
// Note that the identifier TAnimal is arbitrary- you can use any valid Java identifier.
// The syntax for placing a constraint on the type parameter is to use the 'extends' keyword followed by the base class.
// This means that the type argument specified by the client must be Animal or a derived type.
// This allows us to create classes that are more specific and tailored to certain types.
// In this example, the Barn class has a visit method that calls the speak method on the Animal type.
// It would otherwise be impossible to call speak on a generic type without a constraint, since not all types have a speak method.
// Note that Java only supports single inheritance for classes, so you can only specify one class constraint.
class Barn<T extends Animal> extends Container<T> {
	public Barn(T value) {
		super(value);
	}

	public void visit() {
		System.out.printf("Visiting %s...%n", value.getName());
		value.speak();
	}
}